/* opcodes_ed.c: Z80 CBxx opcodes
   Copyright (c) 1999-2008 Philip Kendall, Matthew Westcott

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
	
	Contact details: <matthew@west.co.tt>
	Matthew Westcott, 14 Daisy Hill Drive, Adlington, Chorley, Lancs PR6 9NE UNITED KINGDOM

*/

/* NB: this file is autogenerated by 'z80.pl' from 'opcodes_ed.dat',
   and included in 'z80_ops.jscpp' */

    case 0x40:		/* IN B,(C) */
      tstates += 1;
      IN(B,BCR);
      break;
    case 0x41:		/* OUT (C),B */
      tstates += 1;
      OUT(BCR,B);
      break;
    case 0x42:		/* SBC HL,BC */
      tstates += 7;
      SBC16(BCR);
      break;
    case 0x43:		/* LD (nnnn),BC */
      LD16_NNRR(C,B);
      break;
    case 0x44:
    case 0x4c:
    case 0x54:
    case 0x5c:
    case 0x64:
    case 0x6c:
    case 0x74:
    case 0x7c:		/* NEG */
      {
	var bytetemp=A;
	A=0;
	SUB(bytetemp);
      }
      break;
    case 0x45:
    case 0x4d:
    case 0x55:
    case 0x5d:
    case 0x65:
    case 0x6d:
    case 0x75:
    case 0x7d:		/* RETN */
      IFF1=IFF2;
      RET();
      break;
    case 0x46:
    case 0x4e:
    case 0x66:
    case 0x6e:		/* IM 0 */
      IM=0;
      break;
    case 0x47:		/* LD I,A */
      tstates += 1;
      I=A;
      break;
    case 0x48:		/* IN C,(C) */
      tstates += 1;
      IN(C,BCR);
      break;
    case 0x49:		/* OUT (C),C */
      tstates += 1;
      OUT(BCR,C);
      break;
    case 0x4a:		/* ADC HL,BC */
      tstates += 7;
      ADC16(BCR);
      break;
    case 0x4b:		/* LD BC,(nnnn) */
      LD16_RRNN(C,B);
      break;
    case 0x4f:		/* LD R,A */
      tstates += 1;
      /* Keep the RZX instruction counter right */
      /* rzx_instructions_offset += ( R - A ); */
      R=R7=A;
      break;
    case 0x50:		/* IN D,(C) */
      tstates += 1;
      IN(D,BCR);
      break;
    case 0x51:		/* OUT (C),D */
      tstates += 1;
      OUT(BCR,D);
      break;
    case 0x52:		/* SBC HL,DE */
      tstates += 7;
      SBC16(DER);
      break;
    case 0x53:		/* LD (nnnn),DE */
      LD16_NNRR(E,D);
      break;
    case 0x56:
    case 0x76:		/* IM 1 */
      IM=1;
      break;
    case 0x57:		/* LD A,I */
      tstates += 1;
      A=I;
      F = ( F & FLAG_C ) | sz53_table[A] | ( IFF2 ? FLAG_V : 0 );
      break;
    case 0x58:		/* IN E,(C) */
      tstates += 1;
      IN(E,BCR);
      break;
    case 0x59:		/* OUT (C),E */
      tstates += 1;
      OUT(BCR,E);
      break;
    case 0x5a:		/* ADC HL,DE */
      tstates += 7;
      ADC16(DER);
      break;
    case 0x5b:		/* LD DE,(nnnn) */
      LD16_RRNN(E,D);
      break;
    case 0x5e:
    case 0x7e:		/* IM 2 */
      IM=2;
      break;
    case 0x5f:		/* LD A,R */
      tstates += 1;
      A=(R&0x7f) | (R7&0x80);
      F = ( F & FLAG_C ) | sz53_table[A] | ( IFF2 ? FLAG_V : 0 );
      break;
    case 0x60:		/* IN H,(C) */
      tstates += 1;
      IN(H,BCR);
      break;
    case 0x61:		/* OUT (C),H */
      tstates += 1;
      OUT(BCR,H);
      break;
    case 0x62:		/* SBC HL,HL */
      tstates += 7;
      SBC16(HLR);
      break;
    case 0x63:		/* LD (nnnn),HL */
      LD16_NNRR(L,H);
      break;
    case 0x67:		/* RRD */
      {
	var bytetemp = readbyte( HLR );
	contend( HLR, 7 ); contend( HLR, 3 );
	writebyte(HLR,  ( (A & 0x0f) << 4 ) | ( bytetemp >> 4 ) );
	A = ( A & 0xf0 ) | ( bytetemp & 0x0f );
	F = ( F & FLAG_C ) | sz53p_table[A];
      }
      break;
    case 0x68:		/* IN L,(C) */
      tstates += 1;
      IN(L,BCR);
      break;
    case 0x69:		/* OUT (C),L */
      tstates += 1;
      OUT(BCR,L);
      break;
    case 0x6a:		/* ADC HL,HL */
      tstates += 7;
      ADC16(HLR);
      break;
    case 0x6b:		/* LD HL,(nnnn) */
      LD16_RRNN(L,H);
      break;
    case 0x6f:		/* RLD */
      {
	var bytetemp = readbyte( HLR );
	contend( HLR, 7 ); contend( HLR, 3 );
	writebyte(HLR, ((bytetemp & 0x0f) << 4 ) | ( A & 0x0f ) );
	A = ( A & 0xf0 ) | ( bytetemp >> 4 );
	F = ( F & FLAG_C ) | sz53p_table[A];
      }
      break;
    case 0x70:		/* IN F,(C) */
      tstates += 1;
      {
	var bytetemp;
	IN(bytetemp,BCR);
      }
      break;
    case 0x71:		/* OUT (C),0 */
      tstates += 1;
      OUT(BCR,0);
      break;
    case 0x72:		/* SBC HL,SP */
      tstates += 7;
      SBC16(SPR);
      break;
    case 0x73:		/* LD (nnnn),SP */
      LD16_NNRR(SPLR,SPHR);
      break;
    case 0x78:		/* IN A,(C) */
      tstates += 1;
      IN(A,BCR);
      break;
    case 0x79:		/* OUT (C),A */
      tstates += 1;
      OUT(BCR,A);
      break;
    case 0x7a:		/* ADC HL,SP */
      tstates += 7;
      ADC16(SPR);
      break;
    case 0x7b:		/* LD SP,(nnnn) */
      LD16_RRNNW(SP);
      break;
    case 0xa0:		/* LDI */
      {
	var bytetemp=readbyte( HLR );
	contend( HLR, 3 ); contend( DER, 3 ); contend( DER, 1 ); contend( DER, 1 );
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	writebyte(DER,bytetemp);
	var detemp = (DER + 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	
	bytetemp = (bytetemp + A) & 0xff;
	F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
	  ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
      }
      break;
    case 0xa1:		/* CPI */
      {
	var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
	  lookup = ( (        A & 0x08 ) >> 3 ) |
	           ( (  (value) & 0x08 ) >> 2 ) |
	           ( ( bytetemp & 0x08 ) >> 1 );
	contend( HLR, 3 ); contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	contend( HLR, 1 ); contend( HLR, 1 );
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
	  halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
	  ( bytetemp & FLAG_S );
	if(F & FLAG_H) bytetemp--;
	F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
      }
      break;
    case 0xa2:		/* INI */
      {
	var initemp = readport( BCR );
	tstates += 2; contend_io( BCR, 3 ); contend( HLR, 3 );
	writebyte(HLR,initemp);
	B = (B-1)&0xff;
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
      }
      break;
    case 0xa3:		/* OUTI */
      {
	var outitemp=readbyte( HLR );
	B = (B-1)&0xff;	/* This does happen first, despite what the specs say */
	tstates++; contend( HLR, 4 ); contend_io( BCR, 3 );
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	writeport(BCR,outitemp);
	F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
      }
      break;
    case 0xa8:		/* LDD */
      {
	var bytetemp=readbyte( HLR );
	contend( HLR, 3 ); contend( DER, 3 ); contend( DER, 1 ); contend( DER, 1 );
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	writebyte(DER,bytetemp);
	var detemp = (DER - 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	
	bytetemp = (bytetemp + A) & 0xff;
	F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
	  ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
      }
      break;
    case 0xa9:		/* CPD */
      {
	var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
	  lookup = ( (        A & 0x08 ) >> 3 ) |
	           ( (  (value) & 0x08 ) >> 2 ) |
	           ( ( bytetemp & 0x08 ) >> 1 );
	contend( HLR, 3 ); contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	contend( HLR, 1 ); contend( HLR, 1 );
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
	  halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
	  ( bytetemp & FLAG_S );
	if(F & FLAG_H) bytetemp--;
	F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
      }
      break;
    case 0xaa:		/* IND */
      {
	var initemp = readport( BCR );
	tstates += 2; contend_io( BCR, 3 ); contend( HLR, 3 );
	writebyte(HLR,initemp);
	B = (B-1)&0xff;
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
      }
      break;
    case 0xab:		/* OUTD */
      {
	var outitemp=readbyte( HLR );
	B = (B-1)&0xff;	/* This does happen first, despite what the specs say */
	tstates++; contend( HLR, 4 ); contend_io( BCR, 3 );
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	writeport(BCR,outitemp);
	F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
      }
      break;
    case 0xb0:		/* LDIR */
      {
	var bytetemp=readbyte( HLR );
	contend( HLR, 3 ); contend( DER, 3 ); contend( DER, 1 ); contend( DER, 1 );
	writebyte(DER,bytetemp);
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	var detemp = (DER + 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	bytetemp = (bytetemp + A) & 0xff;
	F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
	  ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
	if(BCR) {
	  contend( DER, 1 ); contend( DER, 1 ); contend( DER, 1 );
	  contend( DER, 1 ); contend( DER, 1 );
	  PC-=2;
	}
      }
      break;
    case 0xb1:		/* CPIR */
      {
	var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
	  lookup = ( (        A & 0x08 ) >> 3 ) |
		   ( (  (value) & 0x08 ) >> 2 ) |
		   ( ( bytetemp & 0x08 ) >> 1 );
	contend( HLR, 3 ); contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	contend( HLR, 1 ); contend( HLR, 1 );
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
	  halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
	  ( bytetemp & FLAG_S );
	if(F & FLAG_H) bytetemp--;
	F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
	if( ( F & ( FLAG_V | FLAG_Z ) ) == FLAG_V ) {
	  contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	  contend( HLR, 1 ); contend( HLR, 1 );
	  PC-=2;
	}
      }
      break;
    case 0xb2:		/* INIR */
      {
	var initemp=readport( BCR );
	tstates += 2; contend_io( BCR, 3 ); contend( HLR, 3 );
	writebyte(HLR,initemp);
	B = (B-1)&0xff;
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
	if(B) {
	  contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	  contend( HLR, 1 );
	  PC-=2;
	}
      }
      break;
    case 0xb3:		/* OTIR */
      {
	var outitemp=readbyte( HLR );
	tstates++; contend( HLR, 4 );
	B = (B-1)&0xff;
	var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	/* This does happen first, despite what the specs say */
	writeport(BCR,outitemp);
	F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
	if(B) {
	  contend_io( BCR, 1 );
	  contend( PC, 1 ); contend( PC, 1 ); contend( PC, 1 );
	  contend( PC, 1 ); contend( PC, 1 ); contend( PC, 1 );
	  contend( PC - 1, 1 );
	  PC-=2;
	} else {
	  contend_io( BCR, 3 );
	}
      }
      break;
    case 0xb8:		/* LDDR */
      {
	var bytetemp=readbyte( HLR );
	contend( HLR, 3 ); contend( DER, 3 ); contend( DER, 1 ); contend( DER, 1 );
	writebyte(DER,bytetemp);
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	var detemp = (DER - 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	bytetemp = (bytetemp + A) & 0xff;
	F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
	  ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
	if(BCR) {
	  contend( DER, 1 ); contend( DER, 1 ); contend( DER, 1 );
	  contend( DER, 1 ); contend( DER, 1 );
	  PC-=2;
	}
      }
      break;
    case 0xb9:		/* CPDR */
      {
	var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
	  lookup = ( (        A & 0x08 ) >> 3 ) |
		   ( (  (value) & 0x08 ) >> 2 ) |
		   ( ( bytetemp & 0x08 ) >> 1 );
	contend( HLR, 3 ); contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	contend( HLR, 1 ); contend( HLR, 1 );
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
	F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
	  halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
	  ( bytetemp & FLAG_S );
	if(F & FLAG_H) bytetemp--;
	F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
	if( ( F & ( FLAG_V | FLAG_Z ) ) == FLAG_V ) {
	  contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	  contend( HLR, 1 ); contend( HLR, 1 );
	  PC-=2;
	}
      }
      break;
    case 0xba:		/* INDR */
      {
	var initemp=readport( BCR );
	tstates += 2; contend_io( BCR, 3 ); contend( HLR, 3 );
	writebyte(HLR,initemp);
	B = (B-1)&0xff;
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
	if(B) {
	  contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 ); contend( HLR, 1 );
	  contend( HLR, 1 );
	  PC-=2;
	}
      }
      break;
    case 0xbb:		/* OTDR */
      {
	var outitemp=readbyte( HLR );
	tstates++; contend( HLR, 4 );
	B = (B-1)&0xff;
	var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
	/* This does happen first, despite what the specs say */
	writeport(BCR,outitemp);
	F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
	/* C,H and P/V flags not implemented */
	if(B) {
	  contend_io( BCR, 1 );
	  contend( PC, 1 ); contend( PC, 1 ); contend( PC, 1 );
	  contend( PC, 1 ); contend( PC, 1 ); contend( PC, 1 );
	  contend( PC - 1, 1 );
	  PC-=2;
	} else {
	  contend_io( BCR, 3 );
	}
      }
      break;
    default:		/* All other opcodes are NOPD */
      break;
