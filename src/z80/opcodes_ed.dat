# opcodes_ed.dat: Z80 ED-prefix extended opcodes
0x40 IN B,(C)
0x41 OUT (C),B
0x42 SBC16 HL,BC
0x43 LD (nnnn),BC
0x44
0x4c
0x54
0x5c
0x64
0x6c
0x74
0x7c NEG
0x45
0x4d
0x55
0x5d
0x65
0x6d
0x75
0x7d RETN
0x46
0x4e
0x66
0x6e IM 0
0x47 LD I,A
0x48 IN C,(C)
0x49 OUT (C),C
0x4a ADC16 HL,BC
0x4b LD BC,(nnnn)
0x4f LD R,A
0x50 IN D,(C)
0x51 OUT (C),D
0x52 SBC16 HL,DE
0x53 LD (nnnn),DE
0x56
0x76 IM 1
0x57 LD A,I
0x58 IN E,(C)
0x59 OUT (C),E
0x5a ADC16 HL,DE
0x5b LD DE,(nnnn)
0x5e
0x7e IM 2
0x5f LD A,R
0x60 IN H,(C)
0x61 OUT (C),H
0x62 SBC16 HL,HL
0x63 LD (nnnn),HL
0x67 RRD
0x68 IN L,(C)
0x69 OUT (C),L
0x6a ADC16 HL,HL
0x6b LD HL,(nnnn)
0x6f RLD
0x70 IN F,(C)
0x71 OUT (C),0
0x72 SBC16 HL,SP
0x73 LD (nnnn),SP
0x78 IN A,(C)
0x79 OUT (C),A
0x7a ADC16 HL,SP
0x7b LD SP,(nnnn)
0xa0 LDI {
      let bytetemp = readbyte( z80.hl() );
      addTstates(8);
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      writebyte(z80.de(),bytetemp);
      const detemp = (z80.de() + 1) & 0xffff; z80.d = detemp >> 8; z80.e = detemp & 0xff;
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      bytetemp = (bytetemp + z80.a) & 0xff;
      z80.f = ( z80.f & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( z80.bc() ? FLAG_V : 0 ) |
        ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
}
0xa1 CPI {
      const value = readbyte( z80.hl() );
      let bytetemp = (z80.a - value) & 0xff;
      const lookup = ( (          z80.a & 0x08 ) >> 3 ) |
                 ( (  (value) & 0x08 ) >> 2 ) |
                 ( ( bytetemp & 0x08 ) >> 1 );
      addTstates(8);
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      z80.f = ( z80.f & FLAG_C ) | ( z80.bc() ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
        halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
        ( bytetemp & FLAG_S );
      if(z80.f & FLAG_H) bytetemp--;
      z80.f |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
}
0xa2 INI {
      const initemp = readport( z80.bc() );
      addTstates(8);
      writebyte(z80.hl(),initemp);
      z80.b = (z80.b-1)&0xff;
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      z80.f = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
}
0xa3 OUTI {
      const outitemp = readbyte( z80.hl() );
      z80.b = (z80.b-1)&0xff;    /* This does happen first, despite what the specs say */
      addTstates(8);
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      writeport(z80.bc(),outitemp);
      z80.f = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
}
0xa8 LDD {
      let bytetemp = readbyte( z80.hl() );
      addTstates(8);
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      writebyte(z80.de(),bytetemp);
      const detemp = (z80.de() - 1) & 0xffff; z80.d = detemp >> 8; z80.e = detemp & 0xff;
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      bytetemp = (bytetemp + z80.a) & 0xff;
      z80.f = ( z80.f & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( z80.bc() ? FLAG_V : 0 ) |
        ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
}
0xa9 CPD {
      const value = readbyte( z80.hl() );
      let bytetemp = (z80.a - value) & 0xff;
      const lookup = ( (          z80.a & 0x08 ) >> 3 ) |
                 ( (  (value) & 0x08 ) >> 2 ) |
                 ( ( bytetemp & 0x08 ) >> 1 );
      addTstates(8);
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      z80.f = ( z80.f & FLAG_C ) | ( z80.bc() ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
        halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
        ( bytetemp & FLAG_S );
      if(z80.f & FLAG_H) bytetemp--;
      z80.f |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
}
0xaa IND {
      const initemp = readport( z80.bc() );
      addTstates(8);
      writebyte(z80.hl(),initemp);
      z80.b = (z80.b-1)&0xff;
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      z80.f = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
}
0xab OUTD {
      const outitemp = readbyte( z80.hl() );
      z80.b = (z80.b-1)&0xff;    /* This does happen first, despite what the specs say */
      addTstates(8);
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      writeport(z80.bc(),outitemp);
      z80.f = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
}
0xb0 LDIR {
      let bytetemp = readbyte( z80.hl() );
      addTstates(8);
      writebyte(z80.de(),bytetemp);
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      const detemp = (z80.de() + 1) & 0xffff; z80.d = detemp >> 8; z80.e = detemp & 0xff;
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      bytetemp = (bytetemp + z80.a) & 0xff;
      z80.f = ( z80.f & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( z80.bc() ? FLAG_V : 0 ) |
        ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
      if(z80.bc()) {
        addTstates(5);
        z80.pc-=2;
      }
}
0xb1 CPIR {
      const value = readbyte( z80.hl() );
      let bytetemp = (z80.a - value) & 0xff;
      const lookup = ( (          z80.a & 0x08 ) >> 3 ) |
                 ( (  (value) & 0x08 ) >> 2 ) |
                 ( ( bytetemp & 0x08 ) >> 1 );
      addTstates(8);
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      z80.f = ( z80.f & FLAG_C ) | ( z80.bc() ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
        halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
        ( bytetemp & FLAG_S );
      if(z80.f & FLAG_H) bytetemp--;
      z80.f |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
      if( ( z80.f & ( FLAG_V | FLAG_Z ) ) == FLAG_V ) {
        addTstates(5);
        z80.pc-=2;
      }
}
0xb2 INIR {
      const initemp = readport( z80.bc() );
      addTstates(8);
      writebyte(z80.hl(),initemp);
      z80.b = (z80.b-1)&0xff;
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      z80.f = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
      if(z80.b) {
        addTstates(5);
        z80.pc-=2;
      }
}
0xb3 OTIR {
      const outitemp = readbyte( z80.hl() );
      addTstates(5);
      z80.b = (z80.b-1)&0xff;
      const hltemp = (z80.hl() + 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      /* This does happen first, despite what the specs say */
      writeport(z80.bc(),outitemp);
      z80.f = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
      if(z80.b) {
        addTstates(8);
        z80.pc-=2;
      } else {
        addTstates(3);
      }
}
0xb8 LDDR {
      let bytetemp = readbyte( z80.hl() );
      addTstates(8);
      writebyte(z80.de(),bytetemp);
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      const detemp = (z80.de() - 1) & 0xffff; z80.d = detemp >> 8; z80.e = detemp & 0xff;
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      bytetemp = (bytetemp + z80.a) & 0xff;
      z80.f = ( z80.f & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( z80.bc() ? FLAG_V : 0 ) |
        ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
      if(z80.bc()) {
        addTstates(5);
        z80.pc-=2;
      }
}
0xb9 CPDR {
      const value = readbyte( z80.hl() );
      let bytetemp = (z80.a - value) & 0xff;
      const lookup = ( (          z80.a & 0x08 ) >> 3 ) |
                 ( (  (value) & 0x08 ) >> 2 ) |
                 ( ( bytetemp & 0x08 ) >> 1 );
      addTstates(8);
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      const bctemp = (z80.bc() - 1) & 0xffff; z80.b = bctemp >> 8; z80.c = bctemp & 0xff;
      z80.f = ( z80.f & FLAG_C ) | ( z80.bc() ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
        halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
        ( bytetemp & FLAG_S );
      if(z80.f & FLAG_H) bytetemp--;
      z80.f |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
      if( ( z80.f & ( FLAG_V | FLAG_Z ) ) == FLAG_V ) {
        addTstates(5);
        z80.pc-=2;
      }
}
0xba INDR {
      const initemp = readport( z80.bc() );
      addTstates(8);
      writebyte(z80.hl(),initemp);
      z80.b = (z80.b-1)&0xff;
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      z80.f = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
      if(z80.b) {
        addTstates(5);
        z80.pc-=2;
      }
}
0xbb OTDR {
      const outitemp = readbyte( z80.hl() );
      addTstates(5);
      z80.b = (z80.b-1)&0xff;
      const hltemp = (z80.hl() - 1) & 0xffff; z80.h = hltemp >> 8; z80.l = hltemp & 0xff;
      /* This does happen first, despite what the specs say */
      writeport(z80.bc(),outitemp);
      z80.f = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[z80.b];
      /* C,H and P/V flags not implemented */
      if(z80.b) {
        addTstates(8);
        z80.pc-=2;
      } else {
        addTstates(3);
      }
}
